;; Analyzed by ClojureScript 1.7.170
{:use-macros {with-compiler-env cljs.env.macros}, :excludes #{}, :name replumb.core, :imports nil, :requires {cljs cljs.js, cljs.js cljs.js, repl replumb.repl, replumb.repl replumb.repl, common replumb.common, replumb.common replumb.common}, :uses nil, :defs {read-eval-call {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 7, :column 16, :end-line 7, :end-column 30, :export true, :arglists (quote ([callback source] [opts callback source])), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false\n  * `:warning-as-error` will consider a compiler warning as error\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Use it if you know what you are doing and follow this\n  protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present\n\n  * `:src-paths`  a vector of paths containing source files\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  ;; a boolean indicating if everything went right\n  :value     ;; (if (success? result)) will contain the actual yield of the evaluation\n  :error     ;; (if (not (success? result)) will contain a js/Error\n  :warning   ;; in case a warning was thrown and :warning-as-error is falsey\n  :form      ;; the evaluated form as data structure (not a string)\n  ```\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness if necessary.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([callback source] [opts callback source]), :arglists ([callback source] [opts callback source]), :arglists-meta (nil nil)}}, :name replumb.core/read-eval-call, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([callback source] [opts callback source]), :arglists ([callback source] [opts callback source]), :arglists-meta (nil nil)}, :method-params ([callback source] [opts callback source]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 7, :end-line 7, :max-fixed-arity 3, :fn-var true, :arglists ([callback source] [opts callback source]), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false\n  * `:warning-as-error` will consider a compiler warning as error\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Use it if you know what you are doing and follow this\n  protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present\n\n  * `:src-paths`  a vector of paths containing source files\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  ;; a boolean indicating if everything went right\n  :value     ;; (if (success? result)) will contain the actual yield of the evaluation\n  :error     ;; (if (not (success? result)) will contain a js/Error\n  :warning   ;; in case a warning was thrown and :warning-as-error is falsey\n  :form      ;; the evaluated form as data structure (not a string)\n  ```\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness if necessary."}, get-prompt {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 76, :column 16, :end-line 76, :end-column 26, :export true, :arglists (quote ([])), :doc "Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."}, :name replumb.core/get-prompt, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 26, :method-params ([]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 76, :end-line 76, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."}, error->str {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 82, :column 16, :end-line 82, :end-column 26, :export true, :arglists (quote ([error] [error print-stack?])), :doc "Return the message string of the input `js/Error`.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([error] [error print-stack?]), :arglists ([error] [error print-stack?]), :arglists-meta (nil nil)}}, :name replumb.core/error->str, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 26, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([error] [error print-stack?]), :arglists ([error] [error print-stack?]), :arglists-meta (nil nil)}, :method-params ([error] [error print-stack?]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 82, :end-line 82, :max-fixed-arity 2, :fn-var true, :arglists ([error] [error print-stack?]), :doc "Return the message string of the input `js/Error`."}, unwrap-result {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 87, :column 16, :end-line 87, :end-column 29, :export true, :arglists (quote ([result-map] [result-map include-warning?])), :doc "Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the value yields from, in order,\n  `:error`, then `:warning` and then eventually `:value`.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([result-map] [result-map include-warning?]), :arglists ([result-map] [result-map include-warning?]), :arglists-meta (nil nil)}}, :name replumb.core/unwrap-result, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([result-map] [result-map include-warning?]), :arglists ([result-map] [result-map include-warning?]), :arglists-meta (nil nil)}, :method-params ([result-map] [result-map include-warning?]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 87, :end-line 87, :max-fixed-arity 2, :fn-var true, :arglists ([result-map] [result-map include-warning?]), :doc "Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the value yields from, in order,\n  `:error`, then `:warning` and then eventually `:value`."}, success? {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 105, :column 16, :end-line 105, :end-column 24, :export true, :arglists (quote ([result-map])), :doc "Given a `result-map`, tells whether the evaluation was successful."}, :name replumb.core/success?, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 24, :method-params ([result-map]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 105, :end-line 105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([result-map])), :doc "Given a `result-map`, tells whether the evaluation was successful."}, result->string {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 110, :column 16, :end-line 110, :end-column 30, :export true, :arglists (quote ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?])), :doc "Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string yields from, in\n  order, `:error`, then `:warning` and then eventually `:value`.\n  - When `print-stack?` is true, the error string will include the stack\n  trace.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists-meta (nil nil nil)}}, :name replumb.core/result->string, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists-meta (nil nil nil)}, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :protocol-impl nil, :export true, :arglists-meta (nil nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 3, :fn-var true, :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :doc "Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string yields from, in\n  order, `:error`, then `:warning` and then eventually `:value`.\n  - When `print-stack?` is true, the error string will include the stack\n  trace."}, browser-options {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 129, :column 16, :end-line 129, :end-column 31, :export true, :arglists (quote ([load-fn!] [src-paths read-file-fn!])), :doc "Creates the browser option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source paths and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([load-fn!] [src-paths read-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!]), :arglists-meta (nil nil)}}, :name replumb.core/browser-options, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([load-fn!] [src-paths read-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!]), :arglists-meta (nil nil)}, :method-params ([load-fn!] [src-paths read-file-fn!]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 129, :end-line 129, :max-fixed-arity 2, :fn-var true, :arglists ([load-fn!] [src-paths read-file-fn!]), :doc "Creates the browser option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source paths and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found)."}, nodejs-options {:protocol-inline nil, :meta {:file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :line 169, :column 16, :end-line 169, :end-column 30, :export true, :arglists (quote ([load-fn!] [src-paths read-file-fn!])), :doc "Creates the Node.js option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source paths and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([load-fn!] [src-paths read-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!]), :arglists-meta (nil nil)}}, :name replumb.core/nodejs-options, :variadic false, :file "file:/Users/kyle/.m2/repository/replumb/replumb/0.1.3/replumb-0.1.3.jar!/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([load-fn!] [src-paths read-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!]), :arglists-meta (nil nil)}, :method-params ([load-fn!] [src-paths read-file-fn!]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 169, :end-line 169, :max-fixed-arity 2, :fn-var true, :arglists ([load-fn!] [src-paths read-file-fn!]), :doc "Creates the Node.js option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source paths and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found)."}}, :require-macros {cljs.env.macros cljs.env.macros}, :cljs.analyzer/constants {:seen #{:read-file-fn! :default :value :nodejs :warning :error :load-fn! :target :success? :src-paths}, :order [:error :value :warning :success? :target :load-fn! :default :read-file-fn! :src-paths :nodejs]}, :doc nil}